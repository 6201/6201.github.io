<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="welcome!"><title>javascript之this | 头号玩家</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript之this</h1><a id="logo" href="/.">头号玩家</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">javascript之this</h1><div class="post-meta">2018-04-28<span> | </span><span class="category"><a href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="post-content"><p>学习javascript时有时候会困惑于this的用法，会指向意外的对象。主要还是理解不够透彻导致的！</p>
<a id="more"></a>

<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）<code>this</code>都指代全局对象。</p>
<figure class="highlight plain"><figcaption><span>lang=javascript</span></figcaption><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在浏览器中, window 对象同时也是全局对象：</span><br><span class="line">console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">a &#x3D; 37;</span><br><span class="line">console.log(window.a); &#x2F;&#x2F; 37</span><br><span class="line"></span><br><span class="line">this.b &#x3D; &quot;MDN&quot;;</span><br><span class="line">console.log(window.b)  &#x2F;&#x2F; &quot;MDN&quot;</span><br><span class="line">console.log(b)         &#x2F;&#x2F; &quot;MDN&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数内部，<code>this</code>的值取决于函数被调用的方式。</p>
<h4 id="简单调用"><a href="#简单调用" class="headerlink" title="简单调用"></a>简单调用</h4><p>因为下面的代码不在严格模式下，且 <code>this</code> 的值不是由该调用设置的，所以 <code>this</code> 的值默认指向全局对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在浏览器中：</span><br><span class="line">f1() &#x3D;&#x3D;&#x3D; window;   &#x2F;&#x2F;在浏览器中，全局对象是window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Node中：</span><br><span class="line">f1() &#x3D;&#x3D;&#x3D; global;</span><br></pre></td></tr></table></figure>
<p>然而，在严格模式下，<code>this</code>将保持他进入执行上下文时的值，所以下面的<code>this</code>将会默认为<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; &#x2F;&#x2F; 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() &#x3D;&#x3D;&#x3D; undefined; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>所以，在<strong>严格模式</strong>下，如果 <code>this</code> 没有被执行上下文（execution context）定义，那它将保持为 <code>undefined</code>。</p>
<p>如果要想把 <code>this</code> 的值从一个上下文传到另一个，就要用 <code>call</code> 或者<code>apply</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。</span><br><span class="line">var obj &#x3D; &#123;a: &#39;Custom&#39;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个属性是在global对象定义的。</span><br><span class="line">var a &#x3D; &#39;Global&#39;;</span><br><span class="line"></span><br><span class="line">function whatsThis(arg) &#123;</span><br><span class="line">  return this.a;  &#x2F;&#x2F; this的值取决于函数的调用方式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatsThis();          &#x2F;&#x2F; &#39;Global&#39;</span><br><span class="line">whatsThis.call(obj);  &#x2F;&#x2F; &#39;Custom&#39;</span><br><span class="line">whatsThis.apply(obj); &#x2F;&#x2F; &#39;Custom&#39;</span><br></pre></td></tr></table></figure>
<p>当一个函数在其主体中使用 <code>this</code> 关键字时，可以通过使用函数继承自<code>Function.prototype</code> 的 <code>call</code> 或 <code>apply</code> 方法将 <code>this</code> 值绑定到调用中的特定对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(c, d) &#123;</span><br><span class="line">  return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;a: 1, b: 3&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个参数是作为‘this’使用的对象</span><br><span class="line">&#x2F;&#x2F; 后续参数作为参数传递给函数调用</span><br><span class="line">add.call(o, 5, 7); &#x2F;&#x2F; 1 + 3 + 5 + 7 &#x3D; 16</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个参数也是作为‘this’使用的对象</span><br><span class="line">&#x2F;&#x2F; 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span><br><span class="line">add.apply(o, [10, 20]); &#x2F;&#x2F; 1 + 3 + 10 + 20 &#x3D; 34</span><br></pre></td></tr></table></figure>
<p>与其他语言相比，<strong>函数的 this 关键字</strong>在 JavaScript 中的表现略有不同，此外，在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>和非严格模式之间也会有一些差别。</p>
<p>在绝大多数情况下，函数的调用方式决定了<code>this</code>的值。<code>this</code>不能在执行期间被赋值，并且在每次函数被调用时<code>this</code>的值也可能会不同。ES5引入了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a>方法来设置函数的<code>this</code>值，而不用考虑函数如何被调用的，ES2015 引入了支持<code>this</code>词法解析的箭头函数（它在闭合的执行上下文内设置<code>this</code>的值）。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this</span><br></pre></td></tr></table></figure>
<h2 id="全局上下文-1"><a href="#全局上下文-1" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）<code>this</code> 都指代全局对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在浏览器中, window 对象同时也是全局对象：</span><br><span class="line">console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">a &#x3D; 37;</span><br><span class="line">console.log(window.a); &#x2F;&#x2F; 37</span><br><span class="line"></span><br><span class="line">this.b &#x3D; &quot;MDN&quot;;</span><br><span class="line">console.log(window.b)  &#x2F;&#x2F; &quot;MDN&quot;</span><br><span class="line">console.log(b)         &#x2F;&#x2F; &quot;MDN&quot;</span><br></pre></td></tr></table></figure>
<h2 id="函数上下文-1"><a href="#函数上下文-1" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数内部，<code>this</code>的值取决于函数被调用的方式。</p>
<h3 id="简单调用-1"><a href="#简单调用-1" class="headerlink" title="简单调用"></a>简单调用</h3><p>因为下面的代码不在严格模式下，且 <code>this</code> 的值不是由该调用设置的，所以 <code>this</code> 的值默认指向全局对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在浏览器中：</span><br><span class="line">f1() &#x3D;&#x3D;&#x3D; window;   &#x2F;&#x2F;在浏览器中，全局对象是window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Node中：</span><br><span class="line">f1() &#x3D;&#x3D;&#x3D; global;</span><br></pre></td></tr></table></figure>
<p>然而，在严格模式下，<code>this</code>将保持他进入执行上下文时的值，所以下面的<code>this</code>将会默认为<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; &#x2F;&#x2F; 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() &#x3D;&#x3D;&#x3D; undefined; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>所以，在<strong>严格模式</strong>下，如果 <code>this</code> 没有被执行上下文（execution context）定义，那它将保持为 <code>undefined</code>。</p>
<p>在第二个例子中，<code>this</code>的确应该是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/undefined">undefined</a>，因为<code>f2</code>是被直接调用的，而不是作为对象的属性或方法调用的（如 <code>window.f2()</code>）。有一些浏览器最初在支持<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>时没有正确实现这个功能，于是它们错误地返回了<code>window</code>对象。</p>
<p>如果要想把 <code>this</code> 的值从一个上下文传到另一个，就要用 <code>call</code> 或者<code>apply</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。</span><br><span class="line">var obj &#x3D; &#123;a: &#39;Custom&#39;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个属性是在global对象定义的。</span><br><span class="line">var a &#x3D; &#39;Global&#39;;</span><br><span class="line"></span><br><span class="line">function whatsThis(arg) &#123;</span><br><span class="line">  return this.a;  &#x2F;&#x2F; this的值取决于函数的调用方式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatsThis();          &#x2F;&#x2F; &#39;Global&#39;</span><br><span class="line">whatsThis.call(obj);  &#x2F;&#x2F; &#39;Custom&#39;</span><br><span class="line">whatsThis.apply(obj); &#x2F;&#x2F; &#39;Custom&#39;</span><br></pre></td></tr></table></figure>
<p>当一个函数在其主体中使用 <code>this</code> 关键字时，可以通过使用函数继承自<code>Function.prototype</code> 的 <code>call</code> 或 <code>apply</code> 方法将 <code>this</code> 值绑定到调用中的特定对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(c, d) &#123;</span><br><span class="line">  return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;a: 1, b: 3&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个参数是作为‘this’使用的对象</span><br><span class="line">&#x2F;&#x2F; 后续参数作为参数传递给函数调用</span><br><span class="line">add.call(o, 5, 7); &#x2F;&#x2F; 1 + 3 + 5 + 7 &#x3D; 16</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个参数也是作为‘this’使用的对象</span><br><span class="line">&#x2F;&#x2F; 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span><br><span class="line">add.apply(o, [10, 20]); &#x2F;&#x2F; 1 + 3 + 10 + 20 &#x3D; 34</span><br></pre></td></tr></table></figure>
<p>使用 <code>call</code> 和 <code>apply</code> 函数的时候要注意，如果传递给 <code>this</code> 的值不是一个对象，JavaScript 会尝试使用内部 <code>ToObject</code> 操作将其转换为对象。因此，如果传递的值是一个原始值比如 <code>7</code> 或 <code>&#39;foo&#39;</code>，那么就会使用相关构造函数将它转换为对象，所以原始值 <code>7</code> 会被转换为对象，像 <code>new Number(7)</code> 这样，而字符串 <code>&#39;foo&#39;</code> 转化成 <code>new String(&#39;foo&#39;)</code> 这样，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">  console.log(Object.prototype.toString.call(this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;原始值 7 被隐式转换为对象</span><br><span class="line">bar.call(7); &#x2F;&#x2F; [object Number]</span><br></pre></td></tr></table></figure>
<h4 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h4><p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>。调用<code>f.bind(someObject)</code>会创建一个与<code>f</code>具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code>将永久地被绑定到了<code>bind</code>的第一个参数，无论这个函数是如何被调用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); &#x2F;&#x2F; azerty</span><br><span class="line"></span><br><span class="line">var h &#x3D; g.bind(&#123;a:&#39;yoo&#39;&#125;); &#x2F;&#x2F; bind只生效一次！</span><br><span class="line">console.log(h()); &#x2F;&#x2F; azerty</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;a:37, f:f, g:g, h:h&#125;;</span><br><span class="line">console.log(o.f(), o.g(), o.h()); &#x2F;&#x2F; 37, azerty, azerty</span><br></pre></td></tr></table></figure>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>中，<code>this</code>与封闭词法上下文的<code>this</code>保持一致。在全局代码中，它将被设置为全局对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var globalObject &#x3D; this;</span><br><span class="line">var foo &#x3D; (() &#x3D;&gt; this);</span><br><span class="line">console.log(foo() &#x3D;&#x3D;&#x3D; globalObject); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>注意：如果将<code>this</code>传递给<code>call</code>、<code>bind</code>、或者<code>apply</code>，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（<code>thisArg</code>）应该设置为<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 接着上面的代码</span><br><span class="line">&#x2F;&#x2F; 作为对象的一个方法调用</span><br><span class="line">var obj &#x3D; &#123;foo: foo&#125;;</span><br><span class="line">console.log(obj.foo() &#x3D;&#x3D;&#x3D; globalObject); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试使用call来设定this</span><br><span class="line">console.log(foo.call(obj) &#x3D;&#x3D;&#x3D; globalObject); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试使用bind来设定this</span><br><span class="line">foo &#x3D; foo.bind(obj);</span><br><span class="line">console.log(foo() &#x3D;&#x3D;&#x3D; globalObject); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>无论如何，<code>foo</code> 的 <code>this</code> 被设置为他被创建时的上下文（在上面的例子中，就是全局对象）。这同样适用于在其他函数内创建的箭头函数：这些箭头函数的<code>this</code>被设置为封闭的词法上下文的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个含有bar方法的obj对象，</span><br><span class="line">&#x2F;&#x2F; bar返回一个函数，</span><br><span class="line">&#x2F;&#x2F; 这个函数返回this，</span><br><span class="line">&#x2F;&#x2F; 这个返回的函数是以箭头函数创建的，</span><br><span class="line">&#x2F;&#x2F; 所以它的this被永久绑定到了它外层函数的this。</span><br><span class="line">&#x2F;&#x2F; bar的值可以在调用中设置，这反过来又设置了返回函数的值。</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  bar: function() &#123;</span><br><span class="line">    var x &#x3D; (() &#x3D;&gt; this);</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span><br><span class="line">&#x2F;&#x2F; 将返回的函数的引用赋值给fn。</span><br><span class="line">var fn &#x3D; obj.bar();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接调用fn而不设置this，</span><br><span class="line">&#x2F;&#x2F; 通常(即不使用箭头函数的情况)默认为全局对象</span><br><span class="line">&#x2F;&#x2F; 若在严格模式则为undefined</span><br><span class="line">console.log(fn() &#x3D;&#x3D;&#x3D; obj); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 但是注意，如果你只是引用obj的方法，</span><br><span class="line">&#x2F;&#x2F; 而没有调用它</span><br><span class="line">var fn2 &#x3D; obj.bar;</span><br><span class="line">&#x2F;&#x2F; 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span><br><span class="line">console.log(fn2()() &#x3D;&#x3D; window); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，一个赋值给了 <code>obj.bar</code>的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 <code>A</code> 调用时，函数B的<code>this</code>被永久设置为obj.bar（函数A）的<code>this</code>。当返回的函数（函数B）被调用时，它<code>this</code>始终是最初设置的。在上面的代码示例中，函数B的<code>this</code>被设置为函数A的<code>this</code>，即obj，所以即使被调用的方式通常将其设置为 <code>undefined</code> 或全局对象（或者如前面示例中的其他全局执行上下文中的方法），它的 <code>this</code> 也仍然是 <code>obj</code> 。</p>
<h3 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h3><p>当函数作为对象里的方法被调用时，它们的 <code>this</code> 是调用该函数的对象。</p>
<p>下面的例子中，当 <code>o.f()</code>被调用时，函数内的<code>this</code>将绑定到<code>o</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); &#x2F;&#x2F; logs 37</span><br></pre></td></tr></table></figure>
<p>请注意，这样的行为，根本不受函数定义方式或位置的影响。在前面的例子中，我们在定义对象<code>o</code>的同时，将函数内联定义为成员 <code>f</code> 。但是，我们也可以先定义函数，然后再将其附属到<code>o.f</code>。这样做会导致相同的行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f &#x3D; independent;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); &#x2F;&#x2F; logs 37</span><br></pre></td></tr></table></figure>
<p>这表明函数是从<code>o</code>的<code>f</code>成员调用的才是重点。</p>
<p>同样，<code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法<code>g</code>当作对象<code>o.b</code>的函数调用。在这次执行期间，函数中的<code>this</code>将指向<code>o.b</code>。事实证明，这与他是对象 <code>o</code> 的成员没有多大关系，最靠近的引用才是最重要的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o.b &#x3D; &#123;g: independent, prop: 42&#125;;</span><br><span class="line">console.log(o.b.g()); &#x2F;&#x2F; 42</span><br></pre></td></tr></table></figure>
<h4 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 **this**"></a>原型链中的 <code>**this**</code></h4><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么<code>this</code>指向的是调用这个方法的对象，就像该方法在对象上一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">  f: function() &#123; </span><br><span class="line">    return this.a + this.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p &#x3D; Object.create(o);</span><br><span class="line">p.a &#x3D; 1;</span><br><span class="line">p.b &#x3D; 4;</span><br><span class="line"></span><br><span class="line">console.log(p.f()); &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>
<p>在这个例子中，对象<code>p</code>没有属于它自己的<code>f</code>属性，它的f属性继承自它的原型。虽然在对 <code>f</code> 的查找过程中，最终是在 <code>o</code> 中找到 <code>f</code> 属性的，这并没有关系；查找过程首先从 <code>p.f</code> 的引用开始，所以函数中的 <code>this</code> 指向<code>p</code>。也就是说，因为<code>f</code>是作为<code>p</code>的方法调用的，所以它的<code>this</code>指向了<code>p</code>。这是 JavaScript 的原型继承中的一个有趣的特性。</p>
<h4 id="getter-与-setter-中的-this"><a href="#getter-与-setter-中的-this" class="headerlink" title="getter 与 setter 中的 this"></a>getter 与 setter 中的 <code>this</code></h4><p>再次，相同的概念也适用于当函数在一个 <code>getter</code> 或者 <code>setter</code> 中被调用。用作 <code>getter</code> 或 <code>setter</code> 的函数都会把 <code>this</code> 绑定到设置或获取属性的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  return this.a + this.b + this.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3,</span><br><span class="line">  get average() &#123;</span><br><span class="line">    return (this.a + this.b + this.c) &#x2F; 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o, &#39;sum&#39;, &#123;</span><br><span class="line">    get: sum, enumerable: true, configurable: true&#125;);</span><br><span class="line"></span><br><span class="line">console.log(o.average, o.sum); &#x2F;&#x2F; logs 2, 6</span><br></pre></td></tr></table></figure>
<h3 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h3><p>当一个函数用作构造函数时（使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new</a>关键字），它的<code>this</code>被绑定到正在构造的新对象。</p>
<p>虽然构造器返回的默认值是<code>this</code>所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回<code>this</code>对象）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 构造函数这样工作:</span><br><span class="line"> *</span><br><span class="line"> * function MyConstructor()&#123;</span><br><span class="line"> *   &#x2F;&#x2F; 函数实体写在这里</span><br><span class="line"> *   &#x2F;&#x2F; 根据需要在this上创建属性，然后赋值给它们，比如：</span><br><span class="line"> *   this.fum &#x3D; &quot;nom&quot;;</span><br><span class="line"> *   &#x2F;&#x2F; 等等...</span><br><span class="line"> *</span><br><span class="line"> *   &#x2F;&#x2F; 如果函数具有返回对象的return语句，</span><br><span class="line"> *   &#x2F;&#x2F; 则该对象将是 new 表达式的结果。 </span><br><span class="line"> *   &#x2F;&#x2F; 否则，表达式的结果是当前绑定到 this 的对象。</span><br><span class="line"> *   &#x2F;&#x2F;（即通常看到的常见情况）。</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">function C()&#123;</span><br><span class="line">  this.a &#x3D; 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o &#x3D; new C();</span><br><span class="line">console.log(o.a); &#x2F;&#x2F; logs 37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C2()&#123;</span><br><span class="line">  this.a &#x3D; 37;</span><br><span class="line">  return &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o &#x3D; new C2();</span><br><span class="line">console.log(o.a); &#x2F;&#x2F; logs 38</span><br></pre></td></tr></table></figure>
<p>在刚刚的例子中（<code>C2</code>），因为在调用构造函数的过程中，手动的设置了返回对象，与<code>this</code>绑定的默认对象被丢弃了。（这基本上使得语句 “<code>this.a = 37;</code>”成了“僵尸”代码，实际上并不是真正的“僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。</p>
<h3 id="作为一个DOM事件处理函数"><a href="#作为一个DOM事件处理函数" class="headerlink" title="作为一个DOM事件处理函数"></a>作为一个DOM事件处理函数</h3><p>当函数被用作事件处理函数时，它的<code>this</code>指向触发事件的元素（一些浏览器在使用非<code>addEventListener</code>的函数动态添加监听函数时不遵守这个约定）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 被调用时，将关联的元素变成蓝色</span><br><span class="line">function bluify(e)&#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.currentTarget); &#x2F;&#x2F; 总是 true</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当 currentTarget 和 target 是同一个对象时为 true</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.target);        </span><br><span class="line">  this.style.backgroundColor &#x3D; &#39;#A5D9F3&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取文档中的所有元素的列表</span><br><span class="line">var elements &#x3D; document.getElementsByTagName(&#39;*&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">for(var i&#x3D;0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">  elements[i].addEventListener(&#39;click&#39;, bluify, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作为一个内联事件处理函数"><a href="#作为一个内联事件处理函数" class="headerlink" title="作为一个内联事件处理函数"></a>作为一个内联事件处理函数</h3><p>当代码被内联<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Event_handlers">on-event 处理函数</a>调用时，它的<code>this</code>指向监听器所在的DOM元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;alert(this.tagName.toLowerCase());&quot;&gt;</span><br><span class="line">  Show this</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>上面的 alert 会显示<code>button</code>。注意只有外层代码中的<code>this</code>是这样设置的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;alert((function()&#123;return this&#125;)());&quot;&gt;</span><br><span class="line">  Show inner this</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，没有设置内部函数的<code>this</code>，所以它指向 global/window 对象（即非严格模式下调用的函数未设置<code>this</code>时指向的默认对象）。</p>
</div><div class="tags"><a href="/tags/%E8%AE%B0%E5%BD%95/"><i class="fa fa-tag"></i>记录</a></div><div class="post-nav"><a class="pre" href="/2018/05/15/Require-js%E4%BB%A5%E5%8F%8AAMD%E8%A7%84%E8%8C%83/">Require.js以及AMD规范</a><a class="next" href="/2018/04/26/webpack%E6%96%87%E6%A1%A3%E3%80%90%E4%B8%80%E3%80%91/">webpack文档【一】</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://6201.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%83%B3%E6%B3%95/">想法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%B0%E5%BD%95/">记录</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">学习</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 15px;">记录</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">编程</a> <a href="/tags/%E7%94%B5%E5%BD%B1/" style="font-size: 15px;">电影</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/29/%E6%97%A5%E5%8E%86%E7%9A%84%E9%9D%A2%E6%9D%BF%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E7%9A%84%EF%BC%9F/">日历的面板是怎么画的？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/29/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/">批量修改文件名</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/vscode%E7%9A%84%E6%8F%92%E4%BB%B6Todo-Tree/">vscode的插件Todo-Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/28/Vue-cli%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5sentry/">Vue-cli项目中引入sentry</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/">移动端调试工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/29/sentry%E9%85%8D%E7%BD%AE/">项目中添加sentry记录一下配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/%E5%AD%A6%E4%B9%A0TypeScript-%E4%BA%8C/">学习TypeScript(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/21/%E5%A6%82%E4%BD%95%E5%9C%A8dva%E4%B8%AD%E5%86%99%E8%BD%AE%E8%AF%A2/">如何在dva中写轮询</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/09/%E5%AD%A6%E4%B9%A0Typescript(%E4%B8%80)/">学习Typescript(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/01/PT%E5%85%A5%E9%97%A8/">PT入门</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://nexmoe.com/" title="折影轻梦" target="_blank">折影轻梦</a><ul></ul><a href="https://scarletsky.github.io/" title="scarletsky.github.io" target="_blank">scarletsky.github.io</a><ul></ul><a href="https://overreacted.io/" title="Overreacted" target="_blank">Overreacted</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">头号玩家.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>